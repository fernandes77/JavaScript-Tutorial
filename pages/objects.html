<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../styles.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <script src="../scripts/objects.js" defer></script>
    <title>Objects</title>
  </head>
  <body>
    <h1>Objects basics</h1>
    <p>
      An object is a collection of related data and/or functionality.
    </p>
    <code>const person = {};</code>
    <h2>Dot notation</h2>
    <p>
      You can access different properties/data/functions with dot notation.
    </p>
    <code>person.name</code><br />
    <code>person.interests[1]</code><br />
    <code>person.bio()</code><br />
    <h2>Bracket notation</h2>
    <p>
      You can also access them with bracket notation. Just put the property in
      quotes.
    </p>
    <code>person["age"]</code><br />
    <code>person["name"]["first"]</code><br />
    <h2>Creating new members</h2>
    <p>
      You can create new members inside an object.
    </p>
    <code>person["eyes"] = "hazel";</code><br />
    <p>
      And they can have dynamic member names too.
    </p>
    <code>person[inputName] = inputValue;</code>
    <h2>What is "this"?</h2>
    <p>
      The <strong>this</strong> keyword refers to the current object the code is
      being written inside.
    </p>
    <code>greeting: function() {</code><br />
    <code>alert('Hi! I\'m ' + <strong>this</strong>.name.first + '.');</code>
    <br />
    <code>}</code>
    <h1>Object-oriented JavaScript</h1>
    <p>
      Object-oriented programming is modeling real world things using objects
      and their data/methods.
    </p>
    <h2>Constructors and object instances</h2>
    <p>
      Constructor functions define the structure of an object.
    </p>
    <code>function <strong>Person</strong>(name) {</code><br />
    <code>this.name = name;</code><br />
    <code>this.greeting = function() {</code><br />
    <code>alert("Hi, my name is " + this.name + ".");</code><br />
    <code>}</code><br />
    <code>}</code><br />
    <p>
      This is JavaScript's version of a class.
    </p>
    <code>let person1 = <strong>new</strong> Person("Rodrigo");</code><br />
    <code>let person2 = <strong>new</strong> Person("Thiago");</code><br />
    <p>The <strong>new</strong> keyword creates a new object.</p>
    <h2>Other ways to create object instances</h2>
    <ul>
      <li><strong>Object()</strong>: creates a new empty object;</li>
      <li>
        <strong>create()</strong>: creates an object with the same
        characteristics as another object.
      </li>
    </ul>
    <h1>Object prototypes</h1>
    <p>
      JavaScript is often described as a prototype based language, because
      objects inherit functions from their parent's
      <strong>prototype</strong>.<br />
      You can see that by checking the list of methods of any object. Some of
      them are inherited from <strong>Object()</strong>.
    </p>
    <h2>The prototype property</h2>
    <p>
      The <strong>prototype</strong> property displays the methods that will be
      inherited by objects that are created from the original object. If a
      method is not inside the <strong>prototype</strong> property then it will
      not be inherited.
    </p>
    <h2>Revisiting create()</h2>
    <p>
      The <strong>Object.create()</strong> method makes the created object
      inherit methods from the copied object.
    </p>
    <h2>The constructor property</h2>
    <p>
      The <strong>constructor</strong> property returns the constructor object.
    </p>
    <code>
      let person3 = new person1.constructor('Karen', 'Stephenson', 26, 'female',
      ['playing drums', 'mountain climbing']);
    </code>
    <br />
    <p>is the same as</p>
    <code>
      let person3 = new Person('Karen', 'Stephenson', 26, 'female', ['playing
      drums', 'mountain climbing']);
    </code>
    <h2>Modifying prototypes</h2>
    <p>
      It is best practice to define properties inside the constructor function
      and leave methods on the prototype. This makes the code easier to read, as
      the constructor only contains the property definitions, and the methods
      are split off into separate blocks.
    </p>
    <h1>Inheritance</h1>
    <p>
      This article shows how to create "child" object classes (constructors)
      that inherit features from their "parent" classes.
    </p>
    <h2>Setting prototype and constructor inheritance</h2>
    <p>
      Creating a <strong>Teacher</strong> object from the
      <strong>Citizen</strong> object:
    </p>
    <code>function Teacher(first, last, age, gender, interests, subject) {</code
    ><br />
    <code>Citizen.call(this, first, last, age, gender, interests);</code><br />
    <code>this.subject = subject;</code><br />
    <code>}</code><br />
    <p>
      Now, to pass the prototype functions we use the
      <strong>create</strong> function:
    </p>
    <code>Teacher.prototype = Object.create(Citizen.prototype);</code><br />
    <p>
      And now, to set the prototype's constructor as equal to Teacher:
    </p>
    <code>
      Object.defineProperty(Teacher.prototype, 'constructor', {
    </code>
    <br />
    <code>value: Teacher, </code><br />
    <code>enumerable: false,</code><br />
    <code>writable: true </code><br />
    <code>});</code><br />
    <p>
      To give Teacher a new function, just use
      <strong>Teacher.prototype</strong>.
    </p>
    <h2>ECMAScript 2015 classes</h2>
    <p>
      ECMAScript 2015 introduces class syntax to JavaScript as a way to write
      reusable classes using easier, cleaner syntax, which is more similar to
      classes in C++ or Java.
    </p>
    <code>class Citizen {</code><br />
    <code>constructor(first, last, age, gender, interests) {</code><br />
    <code>// properties</code><br />
    <code>}</code>
    <br />
    <br />
    <code>// methods</code><br />
    <code>}</code>
    <p>
      And this is how to pass it on to Teacher. We use
      <strong>super()</strong> to define <strong>this</strong>.
    </p>
    <code>class Teacher <strong>extends</strong> Citizen {</code><br />
    <code>
      constructor(first, last, age, gender, interests, subject, grade) {
    </code>
    <br />
    <code>super(first, last, age, gender, interests);</code><br />
    <code>this.subject = subject;</code><br />
    <code>this.grade = grade;</code><br />
    <code>}</code><br />
    <code>}</code><br />
    <h2>Getters and setters</h2>
    <p>
      There may be times when we want to change the values of an attribute in
      the classes we create or we don't know what the final value of an
      attribute will be. We can handle such situations with getters and setters.
    </p>
    <code>get subject() {</code><br />
    <code>return this._subject;</code><br />
    <code>}</code><br /><br />
    <code>set subject(newSubject) {</code><br>
    <code>this._subject = newSubject;</code><br>
    <code>}</code>
  </body>
</html>
